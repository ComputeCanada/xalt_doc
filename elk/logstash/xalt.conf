input {
    beats {
       port => 5044
    }
}

filter {
    if [type] != "xalt_log" {
        drop { }
    }

    if "run" in [tags] {
        prune {
            whitelist_names => ["@timestamp", "@version", "libA", "userT", "tags"]
        }

        mutate {
            rename => ["libA", "libs"]
            rename => ["userT", "data"]

            # Should stay after renames since they are executed before anyway
            remove_field => [
                "[data][run_uuid]", "[data][exec_type]", "[data][cwd]",
                "[data][start_date]", "[data][execModify]", "[data][currentEpoch]"
                ]
        }
    }
    if "link" in [tags] {
        prune {
            whitelist_names => ["@timestamp", "@version", "tags", "function", "resultT", "linkA"]
        }
        
        mutate {
            rename => ["linkA", "libs"]
            rename => ["resultT", "data"]
            rename => ["[data][build_user]", "[data][user]"]
            rename => ["[data][build_syshost]", "[data][cluster]"]
            
            remove_field => [
                "[data][uuid]", "[data][link_program]", "[data][build_epoch]", 
                "[data][exec_path]", "[data][hash_id]", "[data][wd]"
            ]
        }
    }
    
    # Remove library hashes and flatten libA field
    ruby {
        code => "event.set('libs', event.get('libs').map! {|elem| elem[0]})"
    }
}

output {
    stdout {
        codec => rubydebug
    }
    
    if "run" in [tags] {
        elasticsearch {
            index => "xalt-run"
        }
    }
    if "link" in [tags] {
        elasticsearch {
            index => "xalt-link"
        }
    }
    
    
}

